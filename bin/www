#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('viber-nonstandard-order-bot:server');
const https = require('https');
const fs = require('fs');
const { GoogleSpreadsheet } = require('google-spreadsheet');
const nodemailer = require("nodemailer");
const {sheetColumns} = require('../constants');
const {getLastRowIndexWithValue, saveNonstandardOrderRequest} = require('../utils');

const ViberBot = require('viber-bot').Bot;
const BotEvents = require('viber-bot').Events;
const TextMessage = require('viber-bot').Message.Text;

// const qs = require('qs');
// const fetch = require("node-fetch");
//
// const parse = require('date-fns/parse');

require('dotenv').config();

let transporter = nodemailer.createTransport({
  host: "smtp.yandex.ru",
  port: 465,
  secure: true, // true for 465, false for other ports
  auth: {
    user: process.env.POST_USER, // generated ethereal user
    pass: process.env.POST_PASS, // generated ethereal password
  },
});

const sendEmail = async(mailTransporter, to, text) => {
  console.log(`${new Date().toLocaleString('ru')} Gonna send text email`);
  let info = await mailTransporter.sendMail({
    from: `"Fred Foo ðŸ‘»" <${process.env.POST_USER}>`, // sender address
    to: process.env.EMAIL_FOR_TEST, // list of receivers
    subject: "Hello âœ”", // Subject line
    text: "Hello world?", // plain text body
    html: "<b>Hello world?</b>", // html body
  });

  console.log(`${new Date().toLocaleString('ru')} Message sent: %s`, info.messageId);
// Message sent: <b658f8ca-6296-ccf4-8306-87d57a0b4321@example.com>

// Preview only available when sending through an Ethereal account
  console.log(`${new Date().toLocaleString('ru')} Preview URL: %s`, nodemailer.getTestMessageUrl(info));
// Preview URL: https://ethereal.email/message/WaQKMgKddxQDoou...
}

let oldRowCount = 0;

const bot = new ViberBot({
  authToken: process.env.TOKEN,
  name: process.env.NAME,
  avatar: process.env.AVATAR
});

const checkNewOrderRequestAndSend = async (oldCountInner) => {

  const doc = new GoogleSpreadsheet(process.env.SHEET_ID);

  await doc.useApiKey(process.env.SHEET_API_KEY);

  await doc.loadInfo();

  console.log(`${new Date().toLocaleString('ru')} Doc: `, doc.title);

  const sheet = doc.sheetsByIndex[0];

  const newRowCount = sheet.rowCount;

  console.log(`${new Date().toLocaleString('ru')} New rows count: `, newRowCount);
  console.log(`${new Date().toLocaleString('ru')} Old rows count: `, oldCountInner);

  oldRowCount = newRowCount;

  if((oldCountInner > 0) && (oldCountInner < newRowCount)) {
    console.log(`${new Date().toLocaleString('ru')} Count changes from ${oldCountInner} to ${newRowCount}`);
    await sheet.loadCells(`${sheetColumns.timestamp}1:${sheetColumns.specificationPath}${newRowCount}`);
    // await sheet.loadCells(`C1:C${newRowCount}`);
    // await sheet.loadCells(`E1:E${newRowCount}`);
    // await sheet.loadCells(`I1:I${newRowCount}`);
    console.log(`${new Date().toLocaleString('ru')} Got cells`);

    const lastRowIndexWithValue = getLastRowIndexWithValue(sheet);

    for(let rowIndex = 0; rowIndex < (newRowCount - oldCountInner); rowIndex++) {
      // send to back new requests
      const rowIndexForHandle = lastRowIndexWithValue -  rowIndex;
      console.log(`${new Date().toLocaleString('ru')} Timestamp cell value: `, sheet.getCellByA1(`${sheetColumns.timestamp}${rowIndexForHandle}`).value);
      console.log(`${new Date().toLocaleString('ru')} Timestamp date: `, new Date(sheet.getCellByA1(`${sheetColumns.timestamp}${rowIndexForHandle}`).value));
      const request = {
        timestamp: new Date(sheet.getCellByA1(`${sheetColumns.timestamp}${rowIndexForHandle}`).value),
        email: sheet.getCellByA1(`${sheetColumns.email}${rowIndexForHandle}`).value,
        managerName: sheet.getCellByA1(`${sheetColumns.managerName}${rowIndexForHandle}`).value,
        clientStatus: sheet.getCellByA1(`${sheetColumns.clientStatus}${rowIndexForHandle}`).value,
        productName: sheet.getCellByA1(`${sheetColumns.productName}${rowIndexForHandle}`).value,
        description: sheet.getCellByA1(`${sheetColumns.description}${rowIndexForHandle}`).value,
        quantity: sheet.getCellByA1(`${sheetColumns.quantity}${rowIndexForHandle}`).value,
        region: sheet.getCellByA1(`${sheetColumns.region}${rowIndexForHandle}`).value
      }

      if(sheet.getCellByA1(`${sheetColumns.attachments}${rowIndexForHandle}`).value) {
        request.attachments = sheet.getCellByA1(`${sheetColumns.attachments}${rowIndexForHandle}`).value;
      }

      if(sheet.getCellByA1(`${sheetColumns.calculation}${rowIndexForHandle}`).value) {
        request.calculation = sheet.getCellByA1(`${sheetColumns.calculation}${rowIndexForHandle}`).value;
      }

      if(sheet.getCellByA1(`${sheetColumns.duration}${rowIndexForHandle}`).value) {
        request.duration = sheet.getCellByA1(`${sheetColumns.duration}${rowIndexForHandle}`).value;
      }

      if(sheet.getCellByA1(`${sheetColumns.comment}${rowIndexForHandle}`).value) {
        request.comment = sheet.getCellByA1(`${sheetColumns.comment}${rowIndexForHandle}`).value;
      }

      if(sheet.getCellByA1(`${sheetColumns.specificationPath}${rowIndexForHandle}`).value) {
        request.specificationPath = sheet.getCellByA1(`${sheetColumns.specificationPath}${rowIndexForHandle}`).value;
      }

      await saveNonstandardOrderRequest(request);



      // const managerNameCell = sheet.getCellByA1(`C${rowIndexForHandle}`);
      // const productNameCell = sheet.getCellByA1(`E${rowIndexForHandle}`);
      // const regionCell = sheet.getCellByA1(`I${rowIndexForHandle}`);
      // const text = `${regionCell.value}, ${managerNameCell.value}, ${productNameCell.value}`;
      // console.log(`${new Date().toLocaleString('ru')} Text: `, text);
      // bot.sendMessage({id: userId}, new TextMessage(`ÐÐ¾Ð²Ñ‹Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð½Ð° Ð¿Ñ€Ð¾ÑÑ‡Ñ‘Ñ‚:\n ${text}`));
    }

    const usersArr = JSON.parse(process.env.USERS_STR).users;
    console.log(`${new Date().toLocaleString('ru')} Users: `, usersArr);
    for(let userObjIndex = 0; userObjIndex < usersArr.length; userObjIndex++) {
      const userId = usersArr[userObjIndex].viber_id;
      console.log(`${new Date().toLocaleString('ru')} Gonna handle user `, userId);

      console.log(`${new Date().toLocaleString('ru')} lastRowIndexWithValue: `, lastRowIndexWithValue);
      for(let rowIndex = 0; rowIndex < (newRowCount - oldCountInner); rowIndex++) {
        const rowIndexForHandle = lastRowIndexWithValue -  rowIndex;
        const managerNameCell = sheet.getCellByA1(`C${rowIndexForHandle}`);
        const productNameCell = sheet.getCellByA1(`E${rowIndexForHandle}`);
        const regionCell = sheet.getCellByA1(`I${rowIndexForHandle}`);
        const text = `${regionCell.value}, ${managerNameCell.value}, ${productNameCell.value}`;
        console.log(`${new Date().toLocaleString('ru')} Text: `, text);

        if(managerNameCell.value === 'Ð¢ÐµÑÑ‚') {
          console.log(`${new Date().toLocaleString('ru')} Test request, so do not send to bot`);
          continue;
        }
        bot.sendMessage({id: userId}, new TextMessage(`ÐÐ¾Ð²Ñ‹Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð½Ð° Ð¿Ñ€Ð¾ÑÑ‡Ñ‘Ñ‚:\n ${text}`));
      }

    }

  }
}

const checkPrecomputationUpdate = async() => {

};

bot.on(BotEvents.MESSAGE_RECEIVED, (message, response) => {
  // Echo's back the message to the client. Your bot logic should sit here.
  console.log('----------------------------------------------------------------');
  console.log(`${new Date().toLocaleString('ru')}`);
  console.log('New message: ', message.text);
  console.log('From: ', response.userProfile.id);
  console.log('Name: ', response.userProfile.name);
  bot.sendMessage({id: process.env.ADMIN_ID}, new TextMessage(`New message from user: ${response.userProfile.id} ${response.userProfile.name}: ${message.text}`));
  const usersArr = JSON.parse(process.env.USERS_STR).users;
  // console.log('Users: ', usersArr);
  // if(usersArr.some((userObj) => userObj.viber_id === response.userProfile.id)) {
  //   const orderNumber = strToOrderNumber(message.text.trim());
  //   if(orderNumber) {
  //     if(!process.env.ST) {
  //       console.error('Env variable error');
  //       response.send(new TextMessage('ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°'));
  //       return;
  //     }
  //     getParsedOrderData(orderNumber, process.env.ST)
  //         .then((orderObj) => {
  //           if(orderObj && orderObj.data) {
  //             const text = Object.keys(orderObj.data).reduce((acc, key) => {
  //               acc = `${acc} *${key}* :  ${orderObj.data[key].trim()}\n`;
  //               return acc;
  //             }, '');
  //             // console.log('Text: ', text);
  //             response.send(new TextMessage(text));
  //           } else {
  //             response.send(new TextMessage('ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°. ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¾ Ð·Ð°ÐºÐ°Ð·Ðµ'));
  //           }
  //           if(orderObj && orderObj.status) {
  //             const text = Object.keys(orderObj.status).reduce((acc, key) => {
  //               if(orderObj.status[key].isDone) {
  //                 acc = `${acc} *${key.slice(1, -1)}* :  ${orderObj.status[key].doneDate.toLocaleString('ru')} ${orderObj.status[key].userAccessStr}\n`;
  //               } else {
  //                 acc = `${acc} ${key.slice(1, -1)} :  -\n`;
  //               }
  //               return acc;
  //             }, '');
  //             // console.log('Text: ', text);
  //             response.send(new TextMessage(text));
  //           } else {
  //             response.send(new TextMessage('ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°. ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¾ ÑÑ‚Ð°Ñ‚ÑƒÑÐµ'));
  //           }
  //         })
  //   } else {
  //     response.send(new TextMessage('ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð½Ð¾Ð¼ÐµÑ€'));
  //   }
  // } else {
  //   const message = new TextMessage('ÐÐµÑ‚ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð°');
  //   console.log('Unknown user: ', response.userProfile);
  //   bot.getUserDetails(response.userProfile)
  //       .then(userDetails  => {
  //         bot.sendMessage({id: process.env.ADMIN_ID}, new TextMessage(`Unknown user: ${response.userProfile.id} ${response.userProfile.name}`));
  //       })
  //   response.send(message);
  // }
});


/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

const keyPathStr = `${process.env.SSL_KEY_PATH_FILE}`;
const certPathStr = `${process.env.SSL_CERT_PATH_FILE}`;
const caPathStr = `${process.env.SSL_CA_PATH_FILE}`;
// console.log("SSL options: ", keyPathStr, certPathStr, caPathStr);
const serverSSLOptions = {
  key: fs.readFileSync(keyPathStr),
  cert: fs.readFileSync(certPathStr),
  ca: fs.readFileSync(caPathStr),
};

const server = https.createServer(serverSSLOptions, bot.middleware()).listen(port, () => bot.setWebhook(`${process.env.PUBLIC_URL}:${port}`));
// console.log(`${new Date().toLocaleString('ru')} Server created: `, server);
/**
 * Listen on provided port, on all network interfaces.
 */

// server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}

setTimeout(() => checkNewOrderRequestAndSend(oldRowCount), 5000);

setInterval(() => checkNewOrderRequestAndSend(oldRowCount), 60000);
